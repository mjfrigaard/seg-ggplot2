---
title: "SEG - Smoothing heatmap options"
author: "Martin Frigaard"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      tidy = FALSE,
                      size = "small",
                      warning = FALSE,
                      message = FALSE)
library(tidyverse)
library(magrittr)
require(skimr)
require(janitor)
library(heatmap3)
# install.packages("shiny")
library(shiny)
# install.packages("rsconnect")
library(rsconnect)
# install.packages("data.table")
library(data.table)
# install.packages("gplots")
library(gplots)
# install.packages("heatmaply")
library(heatmaply)
library(tools)
# runApp("shinyheatmap")
```

## Smoothing the heatmap 



### Option 1 

This comes from this [stackoverflow](https://stackoverflow.com/questions/48497419/smooth-heatmap-how-to-create-them) question.

```{r RColorBrewer}
library(RColorBrewer)
# Color:
rf <- colorRampPalette(rev(RColorBrewer::brewer.pal(11,'Spectral')))
r <- rf(32)

# Data:
x <- rnorm(mean = 1.5, 5000)
y <- rnorm(mean = 1.6, 5000)
df <- data.frame(x,y)

#Plot:
p <- ggplot(df, aes(x,y))
h3 <- p + stat_bin_hex(bins = 25) + scale_fill_gradientn(colours = r)
h3
```

The answer I am interested in comes from [@Axeman](https://stackoverflow.com/users/4341440/axeman)

> Use `p + stat_density_2d(aes(fill = ..density..), geom = 'raster', contour = FALSE, n = 500) + scale_fill_gradientn(colours=r)`, as [@MrSmithGoesToWashington](https://stackoverflow.com/users/9088378/mrsmithgoestowashington) suggested. (I would preferably use a `viridis` color scale to avoid the banding though.) Also, that plot is not `h3` since it doesn't have hex bins.

These changes produce this graph. 

```{r alterntive-stat_density_2d}
p + stat_density_2d(aes(fill = ..density..), 
                    geom = 'raster', contour = FALSE, n = 500) + 
                          scale_fill_gradientn(colours = r)
```

That's a beauty!

To adapt the `risk_layer_gradient` to this graph, I need to see what the underlying data were for this graph. 

```{r skim-df}
df %>% 
  skimr::skim_to_wide() %>% 
  dplyr::select(variable, 
                mean,
                sd, 
                p50,
                hist)
```

This image has `5000` pixels per square inch. 

## The `stat_density_2d` geom

This is covered in depth on the `ggplot2` [website](https://ggplot2.tidyverse.org/reference/geom_density_2d.html).

```{r geom_density_2d, eval=FALSE}
geom_density_2d(mapping = NULL, data = NULL, stat = "density2d",
  position = "identity", ..., lineend = "butt", linejoin = "round",
  linemitre = 10, na.rm = FALSE, show.legend = NA,
  inherit.aes = TRUE)
```

```{r stat_density_2d, eval=FALSE}
stat_density_2d(mapping = NULL, data = NULL, geom = "density_2d",
  position = "identity", ..., contour = TRUE, n = 100, h = NULL,
  na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)
```

The first example uses the `faithful` data set and starts by creating a basic scatter plot. The variables in the scatter are summarized below. 

```{r}
faithful %>% 
  dplyr::select(eruptions, waiting) %>% 
  skimr::skim_to_wide() %>% 
  dplyr::select(variable,
                n,
                mean,
                sd,
                hist)
```

The plot for `eruptions` vs. `waiting` is below. 

```{r point_plot}
point_plot <- ggplot2::ggplot(data = faithful, aes(x = eruptions, y = waiting)) +
           geom_point() + 
                xlim(0.5, 6) +
                    ylim(40, 110)
point_plot
```

Then if I add the `geom_density_2d` to the scatter plot, I see the graph below. 

```{r point-geom_density_2d}
point_plot + 
  geom_density_2d()
```

By specifying the 

```{r add-geom-polygon}
point_plot + 
  stat_density_2d(aes(fill = stat(level)), geom = "polygon")
```


Get a small sample of the `diamonds` data set.

```{r DiamondsSmall}
set.seed(4393)
DiamondsSmall <- diamonds[base::sample(base::nrow(diamonds), 1000), ]
DiamondsSmall %>% glimpse(78)
```

```{r base_diamonds_plot}
base_diamonds_plot <- ggplot2::ggplot(data = DiamondsSmall, aes(x = x, y = y))
base_diamonds_plot
```

If you map an aesthetic to a categorical variable, you will get a set of contours for each value of that variable.

```{r color-cut}
base_diamonds_plot + 
  ggplot2::geom_density_2d(aes(color = cut))
```

Similarly, if you apply faceting to the plot, contours will be drawn for each facet, but the levels will calculated across all facets

```{r}
base_diamonds_plot + 
  ggplot2::stat_density_2d(aes(fill = stat(level)), geom = "polygon") + 
  ggplot2::scale_fill_viridis_c()
```

```{r nlevel-vs-level}
base_diamonds_plot + 
  stat_density_2d(aes(fill = stat(level)), geom = "polygon") +
  facet_grid(. ~ cut) + 
  scale_fill_viridis_c()
base_diamonds_plot + 
  stat_density_2d(aes(fill = stat(nlevel)), geom = "polygon") +
  facet_grid(. ~ cut) + 
  scale_fill_viridis_c()
```

```{r raster-image}
base_diamonds_plot + 
  stat_density_2d(geom = "raster", 
                  aes(fill = stat(..density..)), 
                  contour = FALSE)
```

```{r risk_base_plot}
risk_base_plot <- ggplot2::ggplot(data = RiskPairData, aes(
      x = REF, # additional aesthetics from new data set
      y = BGM,
      color = abs_risk))
risk_base_plot
```

This can be converted with the `raster` with `stat_density_2d`

```{r risk_base_plot-stat_density_2d}
risk_base_plot + 
  stat_density_2d(geom = "raster", 
                  aes(fill = stat(..density..)), 
                  contour = FALSE)
```

